// Generated by CoffeeScript 1.10.0
(function() {
  var Main, Tsv, main;

  String.prototype.startsWith = function(str) {
    return this.slice(0, str.length) === str;
  };

  String.prototype.endsWith = function(suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
  };

  String.prototype.trim = function() {
    return this.replace(/^\s+|\s+$/g, '');
  };

  String.prototype.count = function(str) {
    var a, i, j, len;
    i = 0;
    for (j = 0, len = this.length; j < len; j++) {
      a = this[j];
      if (a === str) {
        i += 1;
      }
    }
    return i;
  };

  Array.prototype.indexOf = function(obj) {
    var a, i, j, len;
    for (i = j = 0, len = this.length; j < len; i = ++j) {
      a = this[i];
      if (obj === a) {
        return i;
      }
    }
    return -1;
  };

  Tsv = (function() {
    function Tsv() {}

    Tsv.load = function(filePath) {
      var a, body, element_num, elements, file, j, len, ref, text;
      file = new File(filePath);
      file.encoding = "UTF-8";
      file.open("r", "TEXT");
      body = [];
      element_num = 0;
      while (!file.eof) {
        text = file.readln();
        if (element_num === 0) {
          element_num = text.count('\t');
        }
        while (element_num > text.count('\t')) {
          text += file.readln();
        }
        elements = [];
        ref = text.split('\t');
        for (j = 0, len = ref.length; j < len; j++) {
          a = ref[j];
          elements.push(a.replace(/\n/g, " ").replace(/\r/g, " ").replace(/  /g, " "));
        }
        body.push(elements);
      }
      file.close();
      return body;
    };

    return Tsv;

  })();

  Main = (function() {
    function Main() {}

    Main.prototype.run = function() {
      var data, filePath, root;
      root = app.activeDocument;
      filePath = File.openDialog("tsv選択", "*.tsv");
      if (filePath) {
        data = Tsv.load(filePath);
        return this.replace(root, data);
      }
    };

    Main.prototype.replace = function(root, dict) {
      var e, i, index, j, k, keyIndex, l, len, len1, len2, len3, len4, len5, len6, line, lineIndex, m, n, o, original, p, q, ref, ref1, ref2, ref3, replacedTextColor, replaced_texts, start_index, t, text, textArtRange, textFrame, used, valueIndex, warning;
      keyIndex = 0;
      valueIndex = 0;
      lineIndex = dict[0].length;
      replacedTextColor = new CMYKColor();
      replacedTextColor.black = 0;
      replacedTextColor.cyan = 50;
      replacedTextColor.magenta = 100;
      replacedTextColor.yellow = 50;
      ref = dict[0];
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        e = ref[index];
        if (e === 'KEY' || e === 'Key' || e === 'key') {
          keyIndex = index;
        }
        if (e === 'VALUE' || e === 'Value' || e === 'value') {
          valueIndex = index;
        }
      }
      if (keyIndex === 0 && valueIndex === 0) {
        alert("1行目にKEY, VALUEが見つかりません。");
        return;
      }
      for (index = k = 0, len1 = dict.length; k < len1; index = ++k) {
        line = dict[index];
        line[lineIndex] = index + 1;
      }
      used = [];
      used.push(dict[0][keyIndex]);
      dict.sort(function(a, b) {
        return b[keyIndex].length - a[keyIndex].length;
      });
      ref1 = root.textFrames;
      for (l = 0, len2 = ref1.length; l < len2; l++) {
        textFrame = ref1[l];
        if (textFrame.locked) {
          continue;
        }
        if (textFrame.visible) {
          continue;
        }
        text = textFrame.contents.replace(/\n/g, " ").replace(/\r/g, " ").replace(/  /g, " ");
        original = text;
        replaced_texts = [];
        for (index = m = 0, len3 = dict.length; m < len3; index = ++m) {
          line = dict[index];
          if (line[keyIndex] === "" || line[valueIndex] === "") {
            continue;
          }
          start_index = text.indexOf(line[keyIndex]);
          if (start_index !== -1) {
            text = text.replace(line[keyIndex], line[valueIndex]);
            for (n = 0, len4 = replaced_texts.length; n < len4; n++) {
              i = replaced_texts[n];
              if (i[0] > start_index) {
                i[0] += line[valueIndex].length - line[keyIndex].length;
              }
            }
            replaced_texts.push([start_index, line[valueIndex].length]);
            used.push(line[keyIndex]);
          }
        }
        if (replaced_texts.length > 0) {
          textFrame.contents = text;
          textArtRange = textFrame.textRange;
          for (o = 0, len5 = replaced_texts.length; o < len5; o++) {
            t = replaced_texts[o];
            for (i = p = ref2 = t[0], ref3 = t[0] + t[1] - 1; ref2 <= ref3 ? p <= ref3 : p >= ref3; i = ref2 <= ref3 ? ++p : --p) {
              textArtRange.characters[i].fillColor = replacedTextColor;
            }
          }
        }
      }
      dict.sort(function(a, b) {
        return a[lineIndex] - b[lineIndex];
      });
      warning = [];
      for (index = q = 0, len6 = dict.length; q < len6; index = ++q) {
        line = dict[index];
        if (used.indexOf(line[keyIndex]) !== -1) {
          continue;
        }
        warning.push(line[lineIndex] + "行目 - " + line[keyIndex]);
      }
      if (warning.length > 0) {
        return alert("使用されなかったデータがあります。\n" + (warning.join('\n')));
      }
    };

    return Main;

  })();

  main = new Main();

  main.run();

  alert('complete!');

}).call(this);
