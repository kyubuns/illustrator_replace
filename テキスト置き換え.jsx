// Generated by CoffeeScript 1.10.0
(function() {
  var IsPhotoshop, Main, Tsv, main;

  String.prototype.startsWith = function(str) {
    return this.slice(0, str.length) === str;
  };

  String.prototype.endsWith = function(suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
  };

  String.prototype.trim = function() {
    return this.replace(/^\s+|\s+$/g, '');
  };

  String.prototype.count = function(str) {
    var a, i, j, len;
    i = 0;
    for (j = 0, len = this.length; j < len; j++) {
      a = this[j];
      if (a === str) {
        i += 1;
      }
    }
    return i;
  };

  Array.prototype.indexOf = function(obj) {
    var a, i, j, len;
    for (i = j = 0, len = this.length; j < len; i = ++j) {
      a = this[i];
      if (obj === a) {
        return i;
      }
    }
    return -1;
  };

  IsPhotoshop = BridgeTalk !== null && BridgeTalk.appName === 'photoshop';

  Tsv = (function() {
    function Tsv() {}

    Tsv.load = function(filePath) {
      var a, body, element_num, elements, file, j, len, ref, text;
      file = new File(filePath);
      file.encoding = "UTF-8";
      file.open("r", "TEXT");
      body = [];
      element_num = 0;
      while (!file.eof) {
        text = file.readln();
        if (element_num === 0) {
          element_num = text.count('\t');
        }
        while (element_num > text.count('\t')) {
          text += " ";
          text += file.readln();
        }
        elements = [];
        ref = text.split('\t');
        for (j = 0, len = ref.length; j < len; j++) {
          a = ref[j];
          elements.push(a.replace(/\n/g, " ").replace(/\r/g, " ").replace(/  /g, " ").trim());
        }
        body.push(elements);
      }
      file.close();
      return body;
    };

    return Tsv;

  })();

  Main = (function() {
    function Main() {}

    Main.prototype.run = function() {
      var data, filePath, root;
      root = app.activeDocument;
      filePath = File.openDialog("tsv選択", "*.tsv");
      if (filePath) {
        data = Tsv.load(filePath);
        return this.replace(root, data);
      }
    };

    Main.prototype.replace = function(root, dict) {
      var a, e, i, index, j, k, keyIndex, l, len, len1, len2, len3, len4, len5, len6, len7, line, lineIndex, m, n, o, p, q, r, ref, ref1, ref2, replacedTextColor, replaced_texts, start_index, t, text, textArtRange, textFrame, textFrames, used, valueIndex, warning;
      keyIndex = 0;
      valueIndex = 0;
      lineIndex = dict[0].length;
      replacedTextColor = new CMYKColor();
      replacedTextColor.black = 0;
      replacedTextColor.cyan = 50;
      replacedTextColor.magenta = 100;
      replacedTextColor.yellow = 50;
      ref = dict[0];
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        e = ref[index];
        if (e === 'KEY' || e === 'Key' || e === 'key') {
          keyIndex = index;
        }
        if (e === 'VALUE' || e === 'Value' || e === 'value') {
          valueIndex = index;
        }
      }
      if (keyIndex === 0 && valueIndex === 0) {
        alert("1行目にKEY, VALUEが見つかりません。");
        return;
      }
      for (index = k = 0, len1 = dict.length; k < len1; index = ++k) {
        line = dict[index];
        line[lineIndex] = index + 1;
      }
      used = [];
      used.push(dict[0][keyIndex]);
      dict.sort(function(a, b) {
        return b[keyIndex].length - a[keyIndex].length;
      });
      textFrames = root.textFrames;
      if (IsPhotoshop) {
        textFrames = (function() {
          var l, len2, ref1, results;
          ref1 = root.layers;
          results = [];
          for (l = 0, len2 = ref1.length; l < len2; l++) {
            textFrame = ref1[l];
            if (textFrame.kind === LayerKind.TEXT) {
              results.push(textFrame);
            }
          }
          return results;
        })();
      }
      for (l = 0, len2 = textFrames.length; l < len2; l++) {
        textFrame = textFrames[l];
        if (textFrame.locked) {
          continue;
        }
        if (IsPhotoshop) {
          textFrame = textFrame.textItem;
        }
        text = textFrame.contents.replace(/\n/g, " ").replace(/\r/g, " ").replace(/  /g, " ");
        replaced_texts = [];
        for (index = m = 0, len3 = dict.length; m < len3; index = ++m) {
          line = dict[index];
          if (line[keyIndex] === "" || line[valueIndex] === "" || line[keyIndex] === " " || line[valueIndex] === " ") {
            continue;
          }
          start_index = text.indexOf(line[keyIndex]);
          for (n = 0, len4 = replaced_texts.length; n < len4; n++) {
            a = replaced_texts[n];
            if (a[0] <= start_index && start_index < a[0] + a[1]) {
              start_index = -1;
            }
          }
          if (start_index !== -1) {
            text = text.replace(line[keyIndex], line[valueIndex]);
            for (o = 0, len5 = replaced_texts.length; o < len5; o++) {
              i = replaced_texts[o];
              if (i[0] > start_index) {
                i[0] += line[valueIndex].length - line[keyIndex].length;
              }
            }
            replaced_texts.push([start_index, line[valueIndex].length]);
            used.push(line[keyIndex]);
          }
        }
        if (replaced_texts.length > 0) {
          textFrame.contents = text;
          if (!IsPhotoshop) {
            textArtRange = textFrame.textRange;
            for (p = 0, len6 = replaced_texts.length; p < len6; p++) {
              t = replaced_texts[p];
              for (i = q = ref1 = t[0], ref2 = t[0] + t[1] - 1; ref1 <= ref2 ? q <= ref2 : q >= ref2; i = ref1 <= ref2 ? ++q : --q) {
                textArtRange.characters[i].fillColor = replacedTextColor;
              }
            }
          }
        }
      }
      dict.sort(function(a, b) {
        return a[lineIndex] - b[lineIndex];
      });
      warning = [];
      for (index = r = 0, len7 = dict.length; r < len7; index = ++r) {
        line = dict[index];
        if (used.indexOf(line[keyIndex]) !== -1) {
          continue;
        }
        warning.push(line[lineIndex] + "行目 - " + line[keyIndex]);
      }
      if (warning.length > 0) {
        return alert("使用されなかったデータがあります。\n" + (warning.join('\n')));
      }
    };

    return Main;

  })();

  main = new Main();

  main.run();

  alert('complete!');

}).call(this);
